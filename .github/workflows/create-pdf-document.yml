# This workflow takes the pages from GitHub Pages and creates a single markdown file 
# that can be used to generate a PDF using pandoc.
# The workflow is triggered on every commit to the repository.

name: Create a PDF Version of Canine Cleansing Standard

on:
  workflow_call:
    inputs:
      version:
        required: true
        type: string
      mode:
        required: true
        type: string

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: write
  pages: write
  id-token: write


jobs:
  # Build job
  build:
    defaults:
      run:
        shell: pwsh
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create single markdown file
        id: createSingleMarkdown
        run: |
          # This powershell script demonstrates how to create a single markdown file from multiple markdown files
          # and replace the internal links with the generated links.
          # The script is part of the Canine Cleansing Standard (CCS-2025) project.
          # The script is used to generate a single markdown file that can be used to generate a PDF using pandoc.
          # pandoc.exe .\outputmarkdown.md -o output.pdf --toc

          $pandocHeaderFile = "_layouts/pandocheader.tex"
          $reponame = "${{ github.event.repository.name }}"
          $ouputFile = "outputmarkdown.md"
          $readmeFile = "README.md"
          $indexFile = "index.md"   
          $version = "${{ inputs.version }}"
          $mode = "${{ inputs.mode }}"
          Write-Output "Input Version: $version"
          Write-Output "Input Mode: $mode"
          Write-Output "Start preparing version information"
          
          $commitHash = git rev-parse --short HEAD
          
          if ($mode -eq 'build') 
          {
            $verboseVersion = "Draft-$version-$commitHash"
            $verboseVersionPDF = "Draft: $version-$commitHash"

          }
          else
          {
            $verboseVersion = "Release-$version-$commitHash"
            $verboseVersionPDF = "Release: $version-$commitHash"
          }

          $pdffileName = "$reponame-$verboseVersion.pdf"

          Write-Output "Repository: '$reponame'"
          Write-Output "Version: '$version'"
          Write-Output "Mode: '$mode'"
          Write-Output "CommitHash: '$commitHash'"
          Write-Output "VerboseVersion: '$verboseVersion'"
          Write-Output "VerboseVersionPDF: '$verboseVersionPDF'"
          Write-Output "PDF File Name: '$pdffileName'"
         
          Write-Output "pdfFileName=$pdffileName" >>$env:GITHUB_OUTPUT

          $markdownFileNames = @(Get-ChildItem -Path *.md -Exclude $readmeFile, $indexFile, $ouputFile)

          $fileCount = $markdownFileNames.Length
          Write-Output "Files found: $FileCount"

          $pageCollection = @()

          foreach ($markdownFilePath in $markdownFileNames) {
              Write-Output "Processing $markdownFilePath"
              $markdownFileName = $markdownFilePath.Name
              Write-Output "File name: $markdownFileName"
            

              $fileContent = Get-Content -Path $markdownFilePath -Encoding UTF8

              # Find the first line that starts with a Markdown heading indicator (#)
              $firstHeadline = $fileContent | Where-Object { $_ -match '^#+\s+' } | Select-Object -First 1

              # Check if a headline was found
              if ($null -ne $firstHeadline) {
                  Write-Output "First headline found: $firstHeadline"
              } else {
                  Write-Output "No headlines found in the Markdown file."
              }

              $pageCollection += New-Object -Type PSObject -Property @{
                'Filename' = $markdownFileName
                'Path' = $markdownFilePath
                'Headline' = $firstHeadline
                'Content' = $fileContent
                'Linkstring' = [uri]::EscapeDataString($firstHeadline.Trim().Replace("%23%20","#").Replace("%2A","").Replace("%3F","").Replace("%2C","").Replace("%2F","").Replace("%3A","").Replace("%3B","").Replace("%3D","").Replace("%40","").Replace("%26","").Replace("%3C","").Replace("%3E","").Replace("%22","").Replace("%7B","").Replace("%7D","").Replace("%7C","").Replace("%5C","").Replace("%5E","").Replace("%7E","").Replace("%5B","").Replace("%5D","").Replace("%60",""))
              }
          }

          Write-Output $pageCollection.Length

          # Read and add Latex Header file to Output Markdown
          $outputMarkdown = Get-Content $pandocHeaderFile -Raw
          $outputMarkdown = $outputMarkdown.Replace("\def\version",$verboseVersionPDF).Replace("\def\commitid",$commitHash).Replace("\def\tag",$version)

          foreach ($page in $pageCollection) {
              $pageContent = $page.Content
              $pageHeadline = $page.Headline
              $pageLinkString = $page.LinkString
              $pageFilename = $page.Filename
            
              # remove jekyll properties
              $insideFrontMatter = $false
              $filteredContent = ""

              # Loop through each line and remove the front matter
              $filteredContent += "\newpage`n`n"
              foreach ($line in $pageContent) {
                  if ($line -eq "---") {
                      # Toggle the state when encountering ---
                      $insideFrontMatter = -not $insideFrontMatter
                      continue
                  }
                  # If not inside the front matter block, add the line to the output
                  if (-not $insideFrontMatter) {
                      $optimizedLine = $line.Trim()
                      # Write-Output " ***$optimizedLine***"
                      $filteredContent += "$optimizedLine`n"
                  }
              }

              # internal link: [Drying Protocol](#5.%20Drying%20Protocol)<br>
              # External link:[Post Cleaning Care](06_Post-Cleaning_Care.md)<br>

              $outputMarkdown += $filteredContent
              Write-Output "$pageFilename $pageHeadline $pageLinkString"
          }

          #now that we have all the content, in a string we need to replace all the file names with the links generated above
          foreach ($page in $pageCollection) {
              $pageLinkString = $page.LinkString
              $pageFilename = $page.Filename
              $outputMarkdown = $outputMarkdown -replace $pageFilename, $pageLinkString
              Write-Output "Replace: ***$pageFilename*** ***$pageLinkString***"
          }

          Set-Content -Encoding UTF8 -Path $ouputFile -Value $outputMarkdown
          
          # Debug output to Git Hub Actions Summary
          # Get-Content $ouputFile  >> $env:GITHUB_STEP_SUMMARY

      - name: Publish single markdown file
        uses: actions/upload-artifact@v4
        with:
          name: SingleMarkDownFile
          path: outputmarkdown.md
          retention-days: 5
      
      - name: Run Pandoc to create PDF
        uses: docker://pandoc/latex:latest
        with:
            args: outputmarkdown.md -o ${{steps.createSingleMarkdown.outputs.pdfFileName}} --toc

      - name: Publish PDF
        uses: actions/upload-artifact@v4
        with:
          name: ${{steps.createSingleMarkdown.outputs.pdfFileName}}
          path: ${{steps.createSingleMarkdown.outputs.pdfFileName}}
          retention-days: 5
      
      - name: Upload binaries to release
        if: ${{ inputs.mode == 'release' }}
        uses: svenstaro/upload-release-action@2.9.0
        with:
            repo_token: ${{ secrets.GITHUB_TOKEN }}
            file: ./${{steps.createSingleMarkdown.outputs.pdfFileName}}
            asset_name: ${{steps.createSingleMarkdown.outputs.pdfFileName}}
            tag: ${{ github.ref }}
            overwrite: true
 

